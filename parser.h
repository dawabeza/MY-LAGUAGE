#pragma once
#pragma once
#include <vector>
#include <stdexcept>
#include <memory> // Often used for smart pointers to manage the AST
#include "token.h"
#include "ast_node.h" // Includes Stmt and Expr base classes

// Forward declaration for the Declaration base class
class Declaration;

class Parser {
public:
    // Takes the vector of tokens generated by the Scanner.
    Parser(const std::vector<Token>& tokens);

    // The main entry point for the parser, matching the PROGRAM rule.
    std::vector<Declaration*> parse();
	bool Error() const { return hadError; }

private:
    const std::vector<Token>& tokens;
    int current = 0;

    // Flag to indicate if parsing encountered an error.
    bool hadError = false;

    // --- Core Recursive Descent Methods (Matching Grammar Rules) ---

    // Top-level rules
    Declaration* declaration();
    Declaration* varDeclaration();
    Declaration* funDeclaration();

    // Statements
    Stmt* statement();
    Stmt* blockStatement();
    Stmt* ifStatement();
    Stmt* forStatement();
    Stmt* whileStatement();
    Stmt* doWhileStatement();
    Stmt* switchStatement();
    Stmt* breakStatement();
    Stmt* continueStatement();
    Stmt* returnStatement();
    Stmt* printStatement();
    Stmt* exprStatement();

    // Expressions (Lowest precedence first)
    Expr* expression();      // EXPR -> ASSIGNMENT ( "," ASSIGNMENT )*
    Expr* assignment();      // ASSIGNMENT
    Expr* conditional();     // CONDITIONAL
    Expr* logicalOr();       // LOGICAL_OR
    Expr* logicalAnd();      // LOGICAL_AND
    Expr* bitwiseOr();       // BITWISE_OR
    Expr* bitwiseXor();      // BITWISE_XOR
    Expr* bitwiseAnd();      // BITWISE_AND
    Expr* equality();        // EQUALITY
    Expr* comparison();      // COMPARISON
    Expr* shift();           // SHIFT
    Expr* term();            // TERM
    Expr* factor();          // FACTOR
    Expr* unary();           // UNARY
    Expr* postfix();         // POSTFIX
    Expr* primary();         // PRIMARY

    // --- Helper Methods ---
    bool isAtEnd() const;
    Token peek() const;
    Token previous() const;
    Token advance();
    bool check(TokenType type) const;

    // Consume and expect a specific token type, reporting an error if mismatched.
    Token consume(TokenType type, const std::string& message);

    // Check if the current token matches any of the types, consuming it if it does.
    template <typename... Args>
    bool match(Args... types);

    // Error Reporting and Synchronization
    void reportError(const Token& token, const std::string& message);
    void synchronize();

    // Custom Exception for immediate error unwinding
    class ParseError : public std::runtime_error {
    public:
        ParseError() : std::runtime_error("Parser Error") {}
    };

    // Helper for generating ParseError exception
    ParseError error(const Token& token, const std::string& message);
};